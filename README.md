# goit-js-hw-01

# goit-js-hw-05

Задача 5-1 (task-30) function-constructor Напиши функцию-конструктор Account,
которая создает объект со свойствами login и email. В prototype
функции-конструктора добавь метод getInfo(), который возвращает строку со
значениями свойств login и email объекта.

Задача 5-2 (task-31) class Напиши класс User для создания пользователя со
следующим свойствами: name - строка age - число followers - число Добавь метод
getInfo(), который, выводит строку: User ${имя} is ${возраст} years old and has
\${кол-во фоловеров} followers

Задача 5-3 (task-32) использование методов класса Напиши класс Storage, который
будет создавать объекты для управления складом товаров. При вызове будет
получать один аргумент - начальный массив товаров, и записывать его в свойство
items. Добавь методы класса: getItems() - возвращает массив текущих товаров
addItem(item) - получает новый товар и добавляет его к текущим
removeItem(item) - получает товар и, если он есть, удаляет его из текущих

Задача 5-4 (task-33) переиспользование методов класса Напиши класс
StringBuilder. На вход он получает один параметр - строку, которую записывает в
свойство \_value. Добавь классу следующий функционал: Геттер value - возвращает
текущее значение поля \_value Метод append(str) - получает параметр str (строку)
и добавляет ее в конец \_value Метод prepend(str) - получает параметр str
(строку) и добавляет ее в начало value Метод pad(str) - получает параметр str
(строку) и добавляет ее в начало и в конец \_value Метод pad должен использовать
методы append и prepend

Задача 5-5 (task-34) Напиши класс Car с указанными свойствами и методами. class
Car {

- Добавь статический метод `getSpecs(car)`,который принимает объект-машину как
  параметр и выводит в консоль значения свойств maxSpeed, speed, isOn, distance
  и price.

- Конструктор получает объект настроек. Добавь свойства будущеего экземпляра
  класса:
- speed - текущая скорость, изначально 0
- price - цена автомобиля
- maxSpeed - максимальная скорость
- isOn - заведен ли автомобиль, значения true или false. Изначально false
- distance - общий киллометраж, изначально 0 constructor() {}

- Добавь геттер и сеттер для свойства price, который будет работать с свойством
  цены автомобиля.

- Добавь код для того чтобы завести автомобиль.Записывает в свойство isOn
  значение true turnOn() {}

- Добавь код для того чтобы заглушить автомобиль.Записывает в свойство isOn
  значение false, и сбрасывает текущую скорость в 0 turnOff() {}

- Добавялет к свойству speed полученное значение, при условии что результирующая
  скорость не больше чем значение свойства maxSpeed accelerate(value) {}

- Отнимает от свойства speed полученное значение, при условии что результирующая
  скорость не меньше нуля decelerate(value) {}

- Добавляет в поле distance киллометраж (hours х speed),но только в том случае
  если машина заведена! drive(hours) {} }

# goit-js-hw-06

Задача 6-1 map Получи массив имен всех пользователей (свойство name) используя
деструктурирующее присваивание для параметра функции ({name}) без пробелов и
переносов на новую строку.

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Деструктурирующее присваивание для параметра функции PS Деструктурирующее
присваивание (ДП):

Объект как параметр без ДП const object = {num : 2} function getNum (obj) {
return obj.num; } console.log(getNum(object)) // 2 ДП const object = {num : 2}
// const num = object.num; const { num } = object; console.log(num) // 2 Объект
как параметр c ДП const object = {num : 2} //function getNum (obj) { return
obj.num; } function getNum ({num}) { return num; } console.log(getNum(object))
// 2

Задача 6-2 filter Получи массив объектов пользователей, отобранный по цвету глаз
(свойство eyeColor), используя деструктурирующее присваивание для параметра
функции ({eyeColor}) без пробелов и переносов на новую строку.

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Деструктурирующее присваивание для параметра функции PS Деструктурирующее
присваивание (ДП):

Объект как параметр без ДП const object = {num : 2} function getNum (obj) {
return obj.num; } console.log(getNum(object)) // 2 ДП const object = {num : 2}
// const num = object.num; const { num } = object; console.log(num) // 2 Объект
как параметр c ДП const object = {num : 2} //function getNum (obj) { return
obj.num; } function getNum ({num}) { return num; } console.log(getNum(object))
// 2

Задача 6-3 filter, map Получи массив имен пользователей (значение свойства name)
по полу (значение свойства gender).

Используй деструктурирующее присваивание для параметра функции ({name}) без
пробелов и переносов на новую строку.

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-4 filter и оператор ! Получи массив только неактивных пользователей
(отфильтруй по значению свойства isActive)

Используй деструктурирующее присваивание для параметра функции ({isActive}) без
пробелов и переносов на новую строку.

Используй оператор !.

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-5 find Получи объект пользователя (не массив) по уникальному значению
свойства email.

Используй деструктурирующее присваивание для параметра функции ({email}) без
пробелов и переносов на новую строку.

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-6 filter, map и создание анонимных объектов Получи массив из объектов,
которые состоят только из свойств name и email тех пользователей, которые
попадают в возрастную категорию от min до max лет (значение свойства age).

Сравнение, пример

const x = 13;

// num больше 10 ? const larger = num > 10; // true

// num меньше 100 ? const smaller = 100 > num; // true

// num находитя между 10 и 100 ? const between = smaller && larger; // true
Создание анонимных объектов:

const arr = Array(3) .fill('') .map((e,i) => ({['index']: i })); /_ [ { index: 0
}, { index: 1 }, { index: 2 } ] _/ Используй только перебирающие методы массива
которые не изменяют (не мутируют) исходный массив. Т.е. нельзя использовать for,
splice, push и т.п. мутирующие методы.

Задача 6-7 reduce Получи общую сумму баланса (сумму значений свойства balance)
всех пользователей.

Используй деструктурирующее присваивание для параметра функции {balance} без
пробелов и переносов на новую строку

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-8 filter, includes и map Получи массив имен всех пользователей у
которых есть друг с заданным именем.

Используй деструктурирующее присваивание для параметра функции {friends}и
({name}) без пробелов и переносов на новую строку

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-9 sort и map Получи массив имен (поле name) людей, отсортированных в
зависимости от количества их друзей (поле friends)

Избегаем мутации исходного массива: т.к. метод sort изменяет (мутирует) исходный
массив, то следует сделать копию массива и сортировать уже копию, а не исходный
массив.

Копирование массива:

const arr = [1, 3, 5];

// 1 const first = [...arr];

// 2 const second = arr.slice();

// 3 const third = arr.concat(); Используй деструктурирующее присваивание для
параметра функции ({name})` без пробелов и переносов на новую строку

Используй только перебирающие методы массива которые не изменяют (не мутируют)
исходный массив. Т.е. нельзя использовать for, splice, push и т.п. мутирующие
методы.

Задача 6-10 reduce, filter, sort Получи массив всех умений всех пользователей
(поле skills), при этом не должно быть повторяющихся умений и они должны быть
отсортированы в алфавитном порядке.

Слияние массивов:

const odd = [1, 3, 5]; const even = [2, 4, 6];

// 1 [...odd, ...even]; // [1, 3, 5, 2, 4, 6]

// 2 odd.concat(even) // [1, 3, 5, 2, 4, 6] Используй только перебирающие методы
массива которые не изменяют (не мутируют) исходный массив. Т.е. нельзя
использовать for, splice, push и т.п. мутирующие методы.
